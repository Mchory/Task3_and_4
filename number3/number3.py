# -*- coding: utf-8 -*-
"""Number3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZQQUqiU9XcTdHk0UssgeY2FjVwBCWobA
"""

def compute_first(grammar):
    first = {}

    for non_terminal in grammar:
        first[non_terminal] = set()

    while True:
        updated = False

        for non_terminal, productions in grammar.items():
            for production in productions:
                if len(production) > 0:
                    if production[0] in first:
                        if len(first[production[0]]) > 0:
                            initial_size = len(first[non_terminal])
                            first[non_terminal] |= first[production[0]]
                            if len(first[non_terminal]) > initial_size:
                                updated = True

        if not updated:
            break

    return first

def compute_follow(grammar, first):
    follow = {}

    for non_terminal in grammar:
        follow[non_terminal] = set()

    follow[grammar_start] = {'$'}

    while True:
        updated = False

        for non_terminal, productions in grammar.items():
            for production in productions:
                for i in range(len(production) - 1):
                    if production[i] in grammar and production[i+1] in first:
                        initial_size = len(follow[production[i]])
                        follow[production[i]] |= (first[production[i+1]] - {'epsilon'})
                        if len(follow[production[i]]) > initial_size:
                            updated = True

                last_symbol = production[-1]
                if last_symbol in grammar and last_symbol != non_terminal:
                    initial_size = len(follow[last_symbol])
                    follow[last_symbol] |= follow[non_terminal]
                    if len(follow[last_symbol]) > initial_size:
                        updated = True

        if not updated:
            break

    return follow

def construct_ll1_table(grammar, first, follow):
    ll1_table = {}

    for non_terminal, productions in grammar.items():
        for production in productions:
            first_set = set()
            for symbol in production:
                if symbol in first:
                    first_set |= first[symbol] - {'epsilon'}
                if 'epsilon' not in first[symbol]:
                    break
            for terminal in (first_set | follow[non_terminal]):
                if (non_terminal, terminal) in ll1_table:
                    raise ValueError("The grammar is not LL(1)!")
                ll1_table[(non_terminal, terminal)] = production

    return ll1_table

# Example usage:

grammar = {
    'E': ['T+E', 'T'],
    'T': ['F*T', 'F'],
    'F': ['(E)', 'id']
}

grammar_start = 'E'

first = compute_first(grammar)
follow = compute_follow(grammar, first)
ll1_table = construct_ll1_table(grammar, first, follow)

# Print the LL(1) parsing table
print("LL(1) Parsing Table:")
print("".ljust(10), end='')
for terminal in first['E']:
    print(terminal.ljust(10), end='')
print()

for non_terminal in grammar:
    print(non_terminal.ljust(10), end='')
    for terminal in first['E']:
        if (non_terminal, terminal) in ll1_table:
            print(f"{non_terminal} -> {''.join(ll1_table[(non_terminal, terminal)])}".ljust(10), end='')
        else:
            print("".ljust(10), end='')
    print()